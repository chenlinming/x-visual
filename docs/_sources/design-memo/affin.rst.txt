Affine Tweening
===============

.. _affine-design-memo:

Affine Combination
------------------

.. note:: Design and API for affine combination is not stable in current version.
..

To make affine tweening start from where it's finished, and can be combined from
all tweens of the object (component Obj3), it's updated in XTweener like this: ::

..  1. Animizer:
..     compose all scripts into every CmpTween's affine field.
..  2. XTweener.update(): for each tweening update
..     2.1 create the Obj3.combined as each tweening update buffer
..         - Tween.js update target object with interpolated value, not incremental value.
..     2.2 take a snapshot (mesh.matrix) before combine the object's transformations
..         combined.m0 = clone(mesh.matrix);
..     2.3 for each tween sequence, combine the transformation
..         combined.m4.mul(affine[tween]);
..         - to make each tween sequence can be triggered asynchronously, m0 is kept will updating
..     2.4 When all these finished, the results has been applied to Obj3.mesh.matrix,
..         and snapshot has been dropped.

::

    1. Animizer:
       compose all scripts into every CmpTween\'s affine field;
       set combined[i].m0 = undefined
    2. XTweener.update():
       for each entity
         for each tween sequence
           for each tween
             if starting a tween, clear m0;
             update tween;

    3. Affine.update(): for each update
      3.0 for each tween in CmpTweens,
          2.1 if starting a sequence (tween.m0 == undefied), take snapshot of
              Obj3.mesh.matrix -> tween.m0
          2.2 combine affine transformation when the tween is updated -> Obj3.mi
          2.3 if the tween is finished, set Obj3.mesh.matrix -> combined[i].m0
          This is how Tween.js works - tweened value got from the beginning.

let's *f, g* stands for independent transformations, and z-transform for time
expansion, such that

:math:`m_{0} = snapshot`

:math:`m_{1} = f^{1}(m_{0}) z^{1}`

:math:`m_{i} = f^{i}(m_{0}) z^{i} + g^{i - \alpha}(m_{0}) z^{i - \alpha}`

where :math:`\alpha \in Z^{+}`.

`[mathjax cheat sheet] <https://matplotlib.org/tutorials/text/mathtext.html>`_

Affine transformation are cumulated in Obj3.combined.mi:

.. literalinclude:: ../../lib/xmath/affine.js
   :language: javascript
   :lines: 38-50
   :linenos:

.. _affine-issue:

.. attention:: Affine combination is needing to be upgraded to an independent system.
    Currently it's not working correctly.
..

`[mathjax] <https://matplotlib.org/tutorials/text/mathtext.html>`_
