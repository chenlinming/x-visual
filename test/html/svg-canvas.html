<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>XTest-ECS</title>
	<script type='text/javascript' src='../../node_modules/three/build/three.min.js'></script>
	<script type='text/javascript' src='../../dist/xv-0.1.0.min.js'></script>
</head>
<body>
  <canvas id='canv'></canvas>
  <div id='h5-content'>
	<!-- draw your svg on this canvas, which works with providen html2canvas.ems.js -->
	<canvas id='stub' style='display: block; position: absolute;'></canvas>
	<p>Radius <input placeholder='1.0' style='width: 30px'/><br></p>
	<img style='height: 160px; width: 160px', src='../assets/ruler256.png'></img>
  </div>
  <script>
	"use strict";

	class SvgCanvasys extends xv.XObj {
		constructor(ecs, options) {
			super(ecs);
			this.ecs = ecs;
			this.initCanvas('h5-content', ecs, options.xscene);
		}

		update(tick, entities) {
			for (const e of entities) {
				var m = e.Obj3.mesh
				if (e.Canvas.dirty && m) {
					e.Canvas.dirty = false;
					if (!m.material.map){
						m.material.map = e.Canvas.tex;
					}
					m.material.map.needsUpdate = true;
				}
			}
		}

		initCanvas(canvId, ecs, scene) {
			if (ecs) {
				var scrn = ecs.createEntity({
					id: 'screen1',
					Obj3: { geom: xv.XComponent.Obj3Type.PLANE,
							box: [100, 160, 0],		// bounding box also plane size
							mesh: undefined },		// Thrender will handle this
					Visual: {vtype: xv.AssetType.canvas },
					Canvas: {domId: canvId},
				});
			}
		}
	}

	SvgCanvasys.query = { has: ['Visual', 'Canvas', 'Obj3'] };

	const xworld = new xv.XWorld(document.getElementById('canv'),
						window, {canvasize: [480, 320]});
	const ecs = xworld.xecs();
	const xscene = xworld.xscene();

	xworld.addSystem('test', new SvgCanvasys(ecs, {xscene}));

	xworld.startUpdate();

  </script>
</body>
</html>
